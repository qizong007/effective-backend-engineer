# MySQL - ES 双写一致性

## 方案一：同步双写

- 优点
    - 简单粗暴
    - 写入快
- 缺点
    - 业务耦合，扩展性差，代码侵入性强（要在写 mysql 的地方后写 ES 的代码）
    - 影响性能，写入两个存储，响应时间变长，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。
    - 存在双写失败丢数据风险（比如写完MySQL，ES 就挂了）

## 方案二：异步双写

- **优点**
    - 性能高
    - 不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息
    - 多源写入之间相互隔离（业务侧只管发消息），便于扩展更多的数据源写入
- **缺点**
    - 接入新的数据源需要实现新的消费者代码
    - 系统复杂度增加，引入了消息中间件
    - MQ是异步消费模型，存在延迟问题

### 方案 2.1：使用内存队列

> 如 golang 的 channel

1. 把数据写入DB
2. 把数据写入内存队列
3. 消费线程异步从队列中消费数据写入ES（可以做批量优化，定时+定量）

### 方案 2.2：使用分布式消息队列

> 可靠性比内存的更强一些

1. 把数据写入DB
2. 把数据写入MQ
3. 消费线程异步从MQ中消费数据写入ES

> [!tip] 
> MQ 可以缓冲和 DB 的负载能力不一致问题。

## 方案三：定时同步

> 使用定时任务，适合作为兜底的回扫，与其他方案配合（如方案一）

- 优点
    - 实现简单
- 缺点
    - 实时性难以保证
    - 存储压力较大

## 方案四：数据订阅

> 如阿里的 Canal，订阅 MySQL 的 binlog（伪装成DB从节点），发 MQ 消息

- 优点
    - 业务入侵较少
    - 实时性较好
- 缺点
    - 系统复杂度增加，引入了消息中间件和额外组件